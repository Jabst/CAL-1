<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: BnB_UP&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_bn_b___u_p-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BnB_UP&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Branch n Bound implementation, done with max bounds (usually it's done in reverse)  
 <a href="class_bn_b___u_p.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="generic_bn_b_8h_source.html">genericBnB.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1248087eb17017dceaafcc74ad2f9a8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1248087eb17017dceaafcc74ad2f9a8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BnB_UP</b> (vector&lt; T &gt; &amp;elements, double(T::*getCost)(void), double(T::*getValue)(void))</td></tr>
<tr class="separator:a1248087eb17017dceaafcc74ad2f9a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5072c37cae886ccbffa76633b63c1367"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5072c37cae886ccbffa76633b63c1367"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BnB_UP</b> (vector&lt; T * &gt; &amp;elements, void(T::*getCost)(void), void(T::*getValue)(void))</td></tr>
<tr class="separator:a5072c37cae886ccbffa76633b63c1367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52efbfa978fd9b6c43e50da878862d93"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a52efbfa978fd9b6c43e50da878862d93">findUpperBound_1</a> (<a class="el" href="class_bn_b__node.html">BnB_node</a> *node, int *lastItemInBoundIndex, double *latItemInBoundCostUsed)</td></tr>
<tr class="memdesc:a52efbfa978fd9b6c43e50da878862d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find new upper bound. Called only when uncheking.  <a href="#a52efbfa978fd9b6c43e50da878862d93">More...</a><br /></td></tr>
<tr class="separator:a52efbfa978fd9b6c43e50da878862d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c938cc252ed8b58018571f9debe90c"><td class="memItemLeft" align="right" valign="top">vector&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a12c938cc252ed8b58018571f9debe90c">findSolution</a> (double limitCost)</td></tr>
<tr class="memdesc:a12c938cc252ed8b58018571f9debe90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">What do you expect? Finds a solution if there is one for the given BnB problem. (Note: The BnB by itself will not solve problem8, the initial city must be taken into account separately)  <a href="#a12c938cc252ed8b58018571f9debe90c">More...</a><br /></td></tr>
<tr class="separator:a12c938cc252ed8b58018571f9debe90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f7bb7593bd68c64409405ce0137438"><td class="memItemLeft" align="right" valign="top">vector&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#aa3f7bb7593bd68c64409405ce0137438">problem8ApproximateSolve</a> (T *StartPoint, double(T::*firtNodeCost)(void), double limitCost)</td></tr>
<tr class="separator:aa3f7bb7593bd68c64409405ce0137438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37be727765647cb3907a9b183031ba8"><td class="memItemLeft" align="right" valign="top">vector&lt; T * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#ac37be727765647cb3907a9b183031ba8">problem8ApproximateSolve</a> (T StartPoint, double(T::*firtNodeCost)(void), double limitCost)</td></tr>
<tr class="separator:ac37be727765647cb3907a9b183031ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e70ca6c5bddb5467c7b45335922e9ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e70ca6c5bddb5467c7b45335922e9ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a2e70ca6c5bddb5467c7b45335922e9ae">freeHeap</a> ()</td></tr>
<tr class="memdesc:a2e70ca6c5bddb5467c7b45335922e9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear heap used to find solution. do it only after interpreting the solution <br /></td></tr>
<tr class="separator:a2e70ca6c5bddb5467c7b45335922e9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a17570dfb1185be4ab8d1e651b7064ea5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17570dfb1185be4ab8d1e651b7064ea5"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a17570dfb1185be4ab8d1e651b7064ea5">compareElems</a> (typename <a class="el" href="struct_bn_b__pair.html">BnB_pair</a>&lt; T &gt;::typeT a, typename <a class="el" href="struct_bn_b__pair.html">BnB_pair</a>&lt; T &gt;::typeT b)</td></tr>
<tr class="memdesc:a17570dfb1185be4ab8d1e651b7064ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare ratio of the elements. to be used in priority_queue <br /></td></tr>
<tr class="separator:a17570dfb1185be4ab8d1e651b7064ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab8a6d7f562cea7911112b6b7dfd559c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a6d7f562cea7911112b6b7dfd559c6"></a>
vector&lt; <a class="el" href="class_bn_b__node.html">BnB_node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>usedNodes</b></td></tr>
<tr class="separator:ab8a6d7f562cea7911112b6b7dfd559c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8308ba99698255a402675713b1ac6cb0"><td class="memItemLeft" align="right" valign="top">vector&lt; typename <a class="el" href="struct_bn_b__pair.html">BnB_pair</a>&lt; T &gt;::typeT &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a8308ba99698255a402675713b1ac6cb0">ordered_elements</a></td></tr>
<tr class="separator:a8308ba99698255a402675713b1ac6cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0749a907c11c880f825fd0644a8a2bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0749a907c11c880f825fd0644a8a2bfd"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a0749a907c11c880f825fd0644a8a2bfd">maxCost</a></td></tr>
<tr class="memdesc:a0749a907c11c880f825fd0644a8a2bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">the limit (not relevant on initialize, should be set by the methods later) <br /></td></tr>
<tr class="separator:a0749a907c11c880f825fd0644a8a2bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fdb19ab49f1e0dc93700a42c5884f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5fdb19ab49f1e0dc93700a42c5884f9"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#ae5fdb19ab49f1e0dc93700a42c5884f9">minItemCost</a></td></tr>
<tr class="memdesc:ae5fdb19ab49f1e0dc93700a42c5884f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">the min cost found in the items list <br /></td></tr>
<tr class="separator:ae5fdb19ab49f1e0dc93700a42c5884f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b18af61820e672cff387958b393949"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b18af61820e672cff387958b393949"></a>
const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_bn_b___u_p.html#a05b18af61820e672cff387958b393949">maxIterationsAllowed</a> =10000</td></tr>
<tr class="memdesc:a05b18af61820e672cff387958b393949"><td class="mdescLeft">&#160;</td><td class="mdescRight">control variable. Limits the steps used by the algorithm to avoid really heavy computations <br /></td></tr>
<tr class="separator:a05b18af61820e672cff387958b393949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class BnB_UP&lt; T &gt;</h3>

<p>Branch n Bound implementation, done with max bounds (usually it's done in reverse) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a12c938cc252ed8b58018571f9debe90c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T*&gt; <a class="el" href="class_bn_b___u_p.html">BnB_UP</a>&lt; T &gt;::findSolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitCost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What do you expect? Finds a solution if there is one for the given BnB problem. (Note: The BnB by itself will not solve problem8, the initial city must be taken into account separately) </p>
<dl class="section return"><dt>Returns</dt><dd>list of pointers to the elements of the found solution. If no solution is found, will be returned an empty vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a52efbfa978fd9b6c43e50da878862d93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_bn_b___u_p.html">BnB_UP</a>&lt; T &gt;::findUpperBound_1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_bn_b__node.html">BnB_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lastItemInBoundIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>latItemInBoundCostUsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find new upper bound. Called only when uncheking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>node previous to the onde being unchecked </td></tr>
    <tr><td class="paramname">lastItemInBoundIndex</td><td>last item's, used in bound calculation, index, to be given to the new node afterwards </td></tr>
    <tr><td class="paramname">latItemInBoundCostUsed</td><td>last item's, used in bound calculation, used cost found in calculation, to be given to the new node afterwards </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new upperbound calculated </dd></dl>

</div>
</div>
<a class="anchor" id="aa3f7bb7593bd68c64409405ce0137438"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T*&gt; <a class="el" href="class_bn_b___u_p.html">BnB_UP</a>&lt; T &gt;::problem8ApproximateSolve </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>StartPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(T::*)(void)&#160;</td>
          <td class="paramname"><em>firtNodeCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>brief try to find a approximate solution to problem 8 using a BnB approach. Work better if cost of the nodes (time spent on checkpoints) is greater than the edges cost (travel time between checkpoints) ... ... ... NOTE:WILL REMOVE START POINT NODE FROM NODES ... ... ... param StartPoint mem address of the start point (should be the same given to ordered_elements) param firtNodeCost method should return the max cost (or slightly above value) that could be spent travelling in and out of the initil node (note:could be max edge value *2 or even better if could get the sum of the 2 max edges connected to the origin) param limitCost the time limit to visit the given checkpoints return checkpoints that can be visited in any given order without exceeding the limit cost </p>

</div>
</div>
<a class="anchor" id="ac37be727765647cb3907a9b183031ba8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T*&gt; <a class="el" href="class_bn_b___u_p.html">BnB_UP</a>&lt; T &gt;::problem8ApproximateSolve </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>StartPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(T::*)(void)&#160;</td>
          <td class="paramname"><em>firtNodeCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same a the the overload description ut instead of receiving and comparing pointers, uses a copy of the object and compares the object with the operator == </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8308ba99698255a402675713b1ac6cb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; typename <a class="el" href="struct_bn_b__pair.html">BnB_pair</a>&lt;T&gt;::typeT &gt; <a class="el" href="class_bn_b___u_p.html">BnB_UP</a>&lt; T &gt;::ordered_elements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>saves info for each element (cost,value,value/cost ratio) and a pointer for the respective element ordered by higher value/cost ratio </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="generic_bn_b_8h_source.html">genericBnB.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 25 2015 17:55:38 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
